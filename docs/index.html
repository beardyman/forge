<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Home - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="GeneralSQL.html">GeneralSQL</a></li></ul><h3>Interfaces</h3><ul><li><a href="PluginInterface.html">PluginInterface</a></li></ul>
</nav>

<div id="main">
    

    



    


    <section class="package">
        <h3> </h3>		
    </section>









    



    <section class="readme usertext">
        <article><h1>Forge</h1>
<h2>A utility for deploying migrations for changing system state.</h2>
<p><img src="https://github.com/beardyman/forge/actions/workflows/unit-tests.yml/badge.svg" alt="Unit Tests">
<img src="https://github.com/beardyman/forge/actions/workflows/func-tests.yml/badge.svg" alt="Functional Tests"></p>
<p>Migrations are generally database schema alterations or static data updates but can be anything that
is able to be executed via javascript. The common use case (and the reason this lib was written) is for database
schema migrations, however at its core this library just keeps track of state for files that are run, so it can be
used to migrate the state of anything. File state, database state, infrastructure state; it all depends on the
migrations that you create.</p>
<h2>Getting Started</h2>
<ol>
<li>Create a plugin</li>
<li>Create migrations</li>
<li>Configure <code>forge</code> to point to that plugin and migrations</li>
<li>Run <code>forge migrate</code></li>
</ol>
<h2>Why?</h2>
<p>So many alternative migration tools (flyway, knex.js) are written with specific database support and they
are generally bloated supporting many features that many teams don't need. For teams that use multiple
database systems it's sometimes hard to find a single migration tool that supports all of their databases which
leads to using multiple, generally very different, tools.</p>
<p>I wanted to create a tool where users could easily write their own plugin for state management without much effort,
allowing them to setup database connections how they see fit. The user can easily write the logic to create
schemas, tables and inserting state data for this tool so it can easily support any database or system that the user
wants to use.  Technically, a user could use a file or store the state in s3 if they wanted to.</p>
<h3>Why are schema migrations important?</h3>
<p>&quot;Ok, cool, but why would I want to use this tool?&quot;.  I hear it, I get what you're saying. If it just runs js files that
run SQL (or whatever), why can't I do that manually?  Short story is, you can. However, the point of this tool is
to make it easy to manage state across multiple environments for repeatable deployments. This makes it easy to
deploy your schema with your code.  You can run <code>forge</code> with your deployment to deploy database changes alongside code.
This allows you to easily rollout or rollback database changes to match the state of your deployed code.</p>
<h2>How do I use it?</h2>
<h3>Setup a Migration State Plugin</h3>
<p>This is easier than it sounds. Forge requires a plugin to manage its own state to know which files have been run.
This creates an interface for <code>forge</code> to be able to create and manage tables for managing its own state.</p>
<h4>Migration State Plugin requirements</h4>
<p>Forge was written using ESM and requires that its plugins do as well. The plugin must export a class by default and
must implement the following 5 methods:</p>
<ul>
<li><code>createSchema(schema)</code>
<ul>
<li>Creates the schema where the state table resides.  Should be able to be ran repeatedly.</li>
<li><code>schema</code> is a string with the name of the schema.  This is comes from the config (see below).</li>
</ul>
</li>
<li><code>createTable(tableName, tableColumnMap)</code>
<ul>
<li>Creates a table to store the state.</li>
<li><code>tableName</code> is a string with the name of the table from the config.</li>
<li><code>tableColumnMap</code> is an object mapping column names to data types.  All types passed are of type 'text', this may need to
be translated to an acceptable type for your system.</li>
</ul>
</li>
<li><code>insert(columnValueMap)</code>
<ul>
<li>Inserts a record into the state table during a migration.</li>
<li><code>columnValueMap</code> is a mapping of column names to values to be inserted.</li>
</ul>
</li>
<li><code>remove(version)</code>
<ul>
<li>Removes a record from the state table during a rollback.</li>
<li><code>version</code> is the version be removed.</li>
</ul>
</li>
<li><code>getMigrationState()</code>
<ul>
<li>Returns all records from the state table.  Expected format is an array of objects:</li>
</ul>
<pre class="prettyprint source lang-json"><code>[{ &quot;version&quot;: &quot;1&quot;, &quot;name&quot;: &quot;a migration&quot;, &quot;filename&quot;: &quot;v1_a_migration.js&quot;}]
</code></pre>
</li>
</ul>
<p>An interface can be extended if <code>forge</code> is imported into the plugin file.  This will ensure appropriate methods are implemented.</p>
<pre class="prettyprint source lang-js"><code>import PluginInterface from 'forge';

export default class MyStatePlugin extends PluginInterface {
  //...
}
</code></pre>
<p>If using a SQL backend, there is also a General SQL interface that includes all of the necessary functions implemented.  It uses PosgreSQL syntax but
should work for most SQL databases.  It requires that a constructor be made assigning a database interface to <code>this.db</code>.  The database interface must
have a function named <code>query</code>. An example of its implementation creating a connection to a local postgres instance:</p>
<pre class="prettyprint source lang-js"><code>import { GeneralSQLInterface } from 'forge';

import pgp from 'pg-promise';
const pgDb = pgp();
export const pg = pgDb({database: 'postgres'});

export default class Postgres extends Sql {
  constructor(config) {
    super(config);
    this.db = pg; // pg.query will execute queries
  }
}
</code></pre>
<h3>Create migrations</h3>
<p>Migrations must all be placed in a the <code>migrationsDirectory</code> from configuration. It must follow the format: <code>v&lt;version&gt;_&lt;name&gt;.js</code>
For example, the following will result in a migration with <code>version: 1</code> and <code>name: my migration file</code>:</p>
<pre class="prettyprint source"><code>v1_my_migration_file.js
</code></pre>
<p>The version can be any string or number as long as it fits in sort order.</p>
<p>A migration must export two methods: <code>migrate</code> and <code>rollback</code>.  The full forge config will be passed to each method.  Each method must return a promise.<br>
An example migration:</p>
<pre class="prettyprint source lang-js"><code>import {pg} from './postgres.js'; // wrapper around pg-promise

export const migrate = (config) => {
  const query = `
  CREATE TABLE IF NOT EXISTS mySchema.accounts (
    id                int primary key,
    account_settings  jsonb
  );`;
  return pg.query(query);
};

export const rollback = (config) => {
  const query = `
  DROP TABLE IF EXISTS mySchema.accounts;
  `;
  return pg.query(query);
};
</code></pre>
<h3>Configuration</h3>
<p>Forge's configuration should be set in the project's <code>package.json</code> file under the property <code>&quot;forge&quot;</code>. The configuration can be in two different formats.
The default format can be used if there's only one set of migrations in the project.</p>
<p>The only <strong>required</strong> property of a configuration is <code>&quot;migrationStatePlugin&quot;</code>.</p>
<p>Config defaults:</p>
<pre class="prettyprint source lang-json"><code>{
  &quot;logLevel&quot;: &quot;info&quot;,
  &quot;migrationsDirectory&quot;: &quot;migrations&quot;,
  &quot;migrationTable&quot;: &quot;forge_migrations&quot;,
  &quot;schema&quot;: &quot;public&quot;
}
</code></pre>
<p>Example configuration:</p>
<pre class="prettyprint source lang-json"><code>{
  &quot;forge&quot;: {
    &quot;migrationStatePlugin&quot;: &quot;./schema/postgres.js&quot;,
    &quot;migrationsDirectory&quot;: &quot;./schema&quot;,
    &quot;schema&quot;: &quot;test_migrations&quot;,
    &quot;logLevel&quot;: &quot;debug&quot;
  }
}
</code></pre>
<p>The other configuration format is for named configurations.  This can be useful if your project requires two separate migrations.  Names are arbitrary
and there are no limits to how many named migrations you can have.  The defaults above apply to each named configuration.</p>
<pre class="prettyprint source lang-json"><code>{
  &quot;forge&quot;: {
    &quot;logLevel&quot;: &quot;debug&quot;,
    &quot;db&quot;: {
      &quot;migrationStatePlugin&quot;: &quot;./schema/postgres.js&quot;,
      &quot;migrationsDirectory&quot;: &quot;./schema&quot;,
      &quot;schema&quot;: &quot;test_migrations&quot;
    },
    &quot;infra&quot;: {
      &quot;migrationStatePlugin&quot;: &quot;./infra/aws.js&quot;,
      &quot;migrationsDirectory&quot;: &quot;./infra&quot;,
      &quot;schema&quot;: &quot;infra_migrations&quot;
    }
  }
}
</code></pre>
<h3>Run migrate or rollback</h3>
<pre class="prettyprint source lang-shell"><code># record existing migrations
forge initialize

# record existing migrations prior to and including a specific version
forge initialize --version &lt;version>

# migrate to latest
forge migrate

# migrate using a named configuration
forge migrate &lt;name>

# migrate to a specific version
forge migrate --version &lt;version>

# rollback to the previous version
forge rollback

# rollback using a named configuration
forge rollback &lt;name>

# rollback to a specific version (sets the state to the version specified)
forge rollback --version &lt;version>
</code></pre></article>
    </section>






    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a> on Fri Feb 25 2022 12:14:04 GMT-0500 (Eastern Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>